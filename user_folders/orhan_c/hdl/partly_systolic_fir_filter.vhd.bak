library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity partly_systolic_fir_filter is
	
	generic
	(
		filter_taps 	: natural 					:= 16	;
		data_width		: natural 					:= 16	;
		data_size		: natural					:= 16	;
		coeff_width		: natural 					:= 16	;
		par_ser_factor : natural range 0 to 15 := 2	
		
	);
	
	port
	(
		clk 					: in std_logic;
		rst 					: in std_logic;
		
		data_i 				: in std_logic_vector(data_width-1 downto 0);
		data_i_vld			: in std_logic;
		
		filtered_data_o 	: out std_logic_vector(data_width + coeff_width-1 downto 0);
		data_o_vld			: out std_logic
	);
   

end entity;

architecture behavioral of partly_systolic_fir_filter is

   attribute multstyle : string;
   attribute multstyle of behavioral : architecture is "dsp";
	
	signal par_stage_num : integer := par_ser_factor;
	
	type data_array	is array (filter_taps-1 downto 0) of signed(data_width-1 downto 0);
	signal data_arr 		: data_array;
	signal data_count 	: integer range 0 to 15 := 0;
	signal data_arr_full	: std_logic :='0'; 
	
	type coefficients is array (filter_taps-1 downto 0) of signed(coeff_width-1 downto 0);
	constant coeff : coefficients := (
													x"0001", x"0001", x"0001", x"0001",
													x"0001", x"0001", x"0001", x"0001",
													x"0001", x"0001", x"0001", x"0001",
													x"0001", x"0001", x"0001", x"0001"
												);
	
	type filtered_data_array is array (filter_taps-1 downto 0) of signed(data_width+coeff_width-1 downto 0);
	signal filtered_data_arr : filtered_data_array; 

begin

	process(clk) begin
		
		if rising_edge(clk) then
			
			if(rst = '1') then
			
				
			
			else
				
				if(data_i_vld = '1' and data_count < data_size) then
					
					data_count <= data_count + 1 ;
					data_arr(data_count) <= signed(data_i);
				
				end if;
				
				if(data_count = par_stage_num) then
					
					par_stage_num <= par_stage_num + par_stage_num;
					
					if(data_count - par_ser_factor = 0) then
						
						filtered_data_arr(0) <= data_arr(0)*coeff(0);
					
					end if;
				
				end if;
				
				if(data_count >= data_size) then
				
					par_stage_num <= par_ser_factor;
					data_count 	  <= 0;
				
				end if;
			
			case par_ser_factor is
			
				when 1 =>
					
					for i in 1 to fiter_taps - 1 loop
						
						filtered_data_arr(i) <= (filtered_data_arr(i)*coeff(i)) + filtered_data_arr(i-1);
						
					end loop;
			
				
			end if;
		
		end if;
	
	end process;
	
end behavioral;