\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\geometry{margin=1in}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{graphicx}

\title{False Paths Sprint-2 IEEE 1076-2019 VHDL Manual Review}
\author{Mert Ecevit}
\date{Edited at 05.12.2024}

\begin{document}
	
	\maketitle
	\begin{center}
		\textbf{Review and Taken Notes of the Document} \\
		\vspace{1em}
		\textit{Project Leader: Koray Karakurt}
	\end{center}
	
	\newpage
	
	\section*{Chapter 3 Review and Notes}
	
	\subsection*{3.2 Entity Declarations}
	\begin{itemize}[noitemsep]
		\item The entity declaration provides an external view of a component but does not provide information about how a component is implemented.
		\item An entity declaration defines the interface between a given design entity and the environment in which it is used.
		\item A given entity declaration may be shared by many design entities, each of which has a different architecture.
		\item The entity declarative part of a given entity declaration declares items that are common to all design entities whose interfaces are defined by the given entity declaration.
		\item The entity statement part contains concurrent statements that are common to each design entity with this interface.
		\item All entity statements shall be passive. Such statements may be used to monitor the operating conditions or characteristics of a design entity.
	\end{itemize}
	
	\subsection*{3.3 Architecture Declarations}
	\begin{itemize}[noitemsep]
		\item An architecture provides an “internal” view of an entity. An entity may have more than one architecture.
		\item It defines the relationships between the inputs and the outputs of a design entity which may be expressed in terms of:
		\begin{itemize}[noitemsep]
			\item Behavioural style
			\item Data flow style
			\item Structural style
		\end{itemize}
		\item An architecture determines the function of an entity.
		\item It consists of a declaration section where signals, types, constants, components, and subprograms are declared, followed by a collection of concurrent statements.
		\item More than one architecture body may exist corresponding to a given entity declaration.
		\item Each declares a different body with the same interface; thus, each together with the entity declaration represents a different design entity with the same interface.
		\item The architecture statement part contains statements that describe the internal organization and/or operation of the block defined by the design entity.
		\item All of the statements in the architecture statement part are concurrent statements, which execute asynchronously with respect to one another.
	\end{itemize}
	
	\subsection*{3.4 Configuration Declarations}
	\begin{itemize}[noitemsep]
		\item During the design process, a designer may want to experiment with different variations of a design by selecting different architectures.
		\item Configurations can be used to provide fast substitutions of component instances of a structural design.
	\end{itemize}
	
	\subsubsection*{3.4.1 Block Configurations}
	\begin{itemize}[noitemsep]
		\item Blocks are used to organise a set of concurrent statements hierarchically.
	\end{itemize}
	
	\subsubsection*{3.4.2 Component Configurations}
	\begin{itemize}
		\item A component declaration is required to make a design entity useable within the current design.
	\end{itemize}
	
	\section*{Chapter 4 Review and Notes}
	\subsection*{4.2 Subprogram Declarations}
	\begin{itemize}
		\item Subprograms consist of procedures and functions that can be invoked repeatedly from different locations in a VHDL description
		\item VHDL provides two kinds of subprograms : Procedures and Functions
		\item Note: Different from 1076-2002 Document The properties of implicitly declared subtypes denoted by return identifier added in this section.
	\end{itemize}
	
	\subsection*{4.3 Subprogram Bodies}
	\begin{itemize}
		\item A subprogram body specifies the execution of a subprogram
		\item The declaration of subprogram is optional, in absence of that subprogram specification acts as declaration
		\item It is an error if subprogram declarative part declares a shared variable.
	\end{itemize}
	
	\subsection*{4.4 Subprogram Instantiation Declarations}
	\begin{itemize}
		\item \textbf{Note :} This section is is absent in 1076-2002 Document
		\item The uninstantiated subprogram name shall denote an uninstantiated subprogram declared in a subprogram	declaration
		\item Subprogram instantiations is creating anonymous subprograms which allows you to declare and use subprograms  directly within the body of another construct, such as an architecture, without needing a separate named declaration.
	\end{itemize}
	
	\subsection*{4.5 Subprogram Overloading}
	\begin{itemize}
		\item  If the two subprogram names match, the parameter set/return values have to differ. This is called overloading and is allowed for all subprograms. It is especially useful when applied to operators, which can be seen as functions with a special name
		\item This allows, for example, to use the conventional ’+’ symbol for the addition of integer values and, likewise, with bit vectors that should be interpreted as numbers
	\end{itemize}
	
	\subsubsection*{4.5.3 Signatures}
	\begin{itemize}
		\item A signature distinguishes between overloaded subprograms and enumerationliterals based on their parameter and result type profiles. A signature may be used in an attribute name, entity designator or alias declaration.
	\end{itemize}
	
	\subsection*{4.6 Resolution Functions}
	\begin{itemize}
		\item A resolution function defines how values from multiple sources, multiple drivers, are resolved into a single value.
		\item A type or a signal may be defined to have a resolution. This type or signal uses the resolution functions when there are multiple drivers.
	\end{itemize}
	
	\subsection*{4.7 Package Declarations}
	\begin{itemize}
		\item The primary purpose of a package is to collect elements that can be shared among two or more design units.
		\item  It contains some common data types, constants, and subprogram specifications.
		\item A package declaration declares all the names of items that will be seen by the design units that use the package
	\end{itemize}
	
	\subsection*{4.8 Package Bodies}
	\begin{itemize}
		\item A package body contains the implementation details of the subprograms declared in the package declaration.
		\item A package body is not required if no subprograms are declared in a package declaration.
		\item The separation between package declaration and package body serves thesame purpose as the separation between the entity declaration and architecture body.
	\end{itemize}
	
	\subsection*{4.9 Package Instantiation Declarations}
	\begin{itemize}
		\item \textbf{Note :} This section is added in VHDL 1076-2008 document
		\item A package with a generic list is called an uninstantiated package
		\item The uninstantiated package serves as a form of template that we must instantiate separately.
		\item Uninstantiated packages and package instances that are declared as design units and stored in a design library, they  can be written as a further form of design unit
	\end{itemize}
	
	\subsection*{4.10 Conformance Rules}
	\begin{itemize}
		\item Two specifications for one subprogram are conform if 
		\begin{itemize}
			\item A numeric literal can be replaced by a different numeric literal if and only if both have the same
			value.
			\item A simple name can be replaced by an expanded name in which this simple name is the suffix if, and
			only if, at both places the meaning of the simple name is given by the same declaration.
		\end{itemize}
		both specifications are made up of the same sequence of lexical elements and corresponding lexical elements have the same meaning
	\end{itemize}
	
	\section*{Chapter 5 Review and Notes}
	Data types are crucial to the modeling and manipulation of data in the hardware design in VHDL
	
	\subsection*{5.2 Scalar Types}
	\begin{itemize}
		\item Scalar types consist of enumeration types, integer types, physical types, and floating-point types
		\item Enumeration types and integer types are called discrete types. 
		\item Integer types, floating-point types, and physical types are called numeric types.
	\end{itemize}
	
	\subsubsection*{5.2.2 Enumeration types}
	\begin{itemize}
		\item In VHDL, enumeration data types let you provide a collection of named values.
	\end{itemize}
	
	\subsubsection*{5.2.3 Integer Types}
	\begin{itemize}
		\item The signed integers that fall inside a given range are represented by the integer data type
	\end{itemize}
	
	\subsubsection*{5.2.4 Physical Types}
	\begin{itemize}
		\item Physical type is a numeric scalar that represents some quantity
	\end{itemize}
	
	\subsubsection*{5.2.5 Floating-Point Types}
	\begin{itemize}
		\item Floating point type provides an approximation of the real number value.
	\end{itemize}
	
	\subsection*{5.3 Composite Types}
	\begin{itemize}
		\item A composite type object is one having multiple elements
	\end{itemize}
	
	\subsubsection*{5.3.2 Array Type}
	\begin{itemize}
		\item Collections of the same data type elements are referred to as arrays in VHDL
	\end{itemize}
	
	\subsubsection*{5.3.3 Record Type}
	\begin{itemize}
		\item Records define custom data types that contain multiple fields of different data types
	\end{itemize}
	
	\subsection*{5.4 Access Types}
	\begin{itemize}
		\item Access type allows to manipulate data, which are created dynamically during simulation and which exact size is not known in advance
	\end{itemize}
	
	\subsection*{5.5 File Types}
	\begin{itemize}
		\item A type that provides access to objects containing a sequence of values of a given type
	\end{itemize}
	
	\subsection*{5.6 Protection Types}
	\begin{itemize}
		\item Types which implements instantiatiable regions of sequential statements and have exclusive access to shared data
	\end{itemize}
	
	\subsection*{5.7 String Representation}
	\begin{itemize}
		\item Character arrays are called strings. Used frequently to manipulate files or textual data.
	\end{itemize}
	
	\subsection*{5.8 Unspecified Types}
	\begin{itemize}
		\item An unspecified type abstractly defines the type class for generics, ports, parameters, and external names
	\end{itemize}
	
	\section*{Chapter 6 Review and Notes}
	\begin{itemize}
		\item Various declarations may be used in various design units.
	\end{itemize}
	
	\subsection*{6.2 Type Declarations}
	\begin{itemize}
		\item Custom structures and types for more accurate data representation are made possible by type declarations, which establish new data types in VHDL.
	\end{itemize}
	
	\subsection*{6.3 Subtype Declarations}
	\begin{itemize}
		\item A type together with a constraint.
	\end{itemize}
	
	\subsection*{6.4 Objects}
	\begin{itemize}
		\item Object are constants, signals and variables.
	\end{itemize}
	
	\subsection*{6.5 Interface Declarations}
	\begin{itemize}
		\item Interface declarations define interface objects of a precisely defined type.
		\item Interface objects are interface constants, interface signals, interface variables and interface files.
	\end{itemize}
	
	\subsection*{6.6 Alias Declarations}
	\begin{itemize}
		\item An alias is an alternative name for an existing object (signal, variable or constant). They don't define a new object.
	\end{itemize}
	
	\subsection*{6.7 Attribute Declarations}
	\begin{itemize}
		\item Attributes are user-defined properties attached to types, signals, entities, etc. They can store metadata or control simulation aspects.
	\end{itemize}
	
	\subsection*{6.8 Component Declarations}
	\begin{itemize}
		\item Components act as templates for modules or logic blocks that can be instantiated multiple times in a design. This allows reusability and modular design.
	\end{itemize}
	
	
	
	\section{Chapter 7 Review and Notes}
	\begin{itemize}
		\item In VHDL, Specifications are used to define additional information associated with entity in a design.
	\end{itemize}
	
	\subsection*{7.2 Attribute Specifications}
	\begin{itemize}
		\item Attributes are a feature of VHDL that allow you to extract additional information about an object.
	\end{itemize}
	
	\subsection*{7.3 Configuration Specifications}
	\begin{itemize}
		\item A VHDL configuration specification defines how instances of a specific component are connected and used in a design.
		\item It associates component instances with binding information, determining the role of the component within the design structure.
	\end{itemize}
	
	\subsection*{7.4 Disconnection Specification}
	\begin{itemize}
		\item A disconnection specification defines the time delay after which the driver of a guarded signal will automatically disconnect. It controls how long a signal remains active before it is disconnected.
	\end{itemize}
	
	
	
	\section*{Chapter 8 Review and Notes}
	\begin{itemize}
		\item In code, names refer to various entities like objects, values, methods, attributes, or slices.
	\end{itemize}
	
	\subsection*{8.2 Simple Names}
	\begin{itemize}
		\item While selected names denote a sub-element, simple names explicitly identify an item.
	\end{itemize}
	
	\subsection*{8.3 Selected Names}
	\begin{itemize}
		\item When referring to an entity that is declared within another entity or a design library, selected names are utilized.
	\end{itemize}
	
	\subsection*{8.4 Indexed Names}
	\begin{itemize}
		\item The indexed name indicates an element of an array, which is indicated by an expression list forming the array index.
	\end{itemize}
	
	\subsection*{8.5 Slice Names}
	\begin{itemize}
		\item The slice name allows indicating a part of a one-dimensional array. The slice name is called a null slice if its discrete range is a null range
	\end{itemize}
	
	\subsection*{8.6 Attribute Names}
	\begin{itemize}
		\item The attribute name consists of two elements: a prefix and an attribute designator
	\end{itemize}
	
	\subsection*{8.7 External Names}
	\begin{itemize}
		\item An object designated in the design hierarchy that contains the external name is indicated by its external name.
	\end{itemize}
	
	
	\section*{Chapter 9 Review and Notes}
	\begin{itemize}
		\item A formula that defines the computation of a value.
		\item The type of an expression depends only upon 
		\begin{itemize}
			\item The types of its operands 
			\item On the operators applied
		\end{itemize}
		\item The operators that can be used in expressions are defined below:
		
		\begin{figure}
			\centering
			\includegraphics[width=0.7\linewidth]{"../../../../../Pictures/Screenshots/Ekran görüntüsü 2024-12-09 002158"}
			\caption{}
			\label{fig:ekran-goruntusu-2024-12-09-002158}
		\end{figure}
		\begin{figure}
			\centering
			\includegraphics[width=0.7\linewidth]{"../../../../../Pictures/Screenshots/Ekran görüntüsü 2024-12-09 002209"}
			\caption{}
			\label{fig:ekran-goruntusu-2024-12-09-002209}
		\end{figure}
		\begin{figure}
			\centering
			\includegraphics[width=0.7\linewidth]{"../../../../../Pictures/Screenshots/Ekran görüntüsü 2024-12-09 002215"}
			\caption{}
			\label{fig:ekran-goruntusu-2024-12-09-002215}
		\end{figure}	
	\end{itemize}
	
	\subsection*{9.3 Operands}
	\begin{itemize}
		\item The operands in an expression include names (that denote objects, values, or attributes that result in a value),
		literals, aggregates, function calls, qualified expressions, type conversions, and allocators. In addition, an
		expression enclosed in parentheses may be an operand in an expression.
	\end{itemize}
	
	
	\subsection*{9.4 Static Expressions}
	\begin{itemize}
		\item Utilized in constant declarations or restrictions; fully computed at compile time.
		\item There are two categories of static expression:
		\begin{itemize}
			\item If every operator in expression is an implicit defined operator, these are called \textbf{locally static}  expressions
			\item If every in the expression is a pure function and every primary in the expression is a global static primary, they are called \textbf{globally static}  expressions
		\end{itemize}
	\end{itemize}
	
	\subsection*{9.5 Universal Expressions}
	\begin{itemize}
		\item A universal expression is either an expression that delivers a result of type universal integer or one that delivers a result of type \textbf{universal real}
		\item The same operations are predefined for the type \textbf{universal integer} as for any integer type
		\item The same operations are predefined for the type \textbf{universal real} as for any floating point type
		\item In addition, these operations include the multiplication and division operators
		
	\end{itemize}
	
	
	\section*{Chapter 10 Notes and Review}
	
	
	\subsection*{10.2 Wait Statement}
	\begin{itemize}
		\item Causes execution of sequential statements to wait.
		\item Includes optional sensitivity clause, condition clause, or timeout clause.
	\end{itemize}
	
	\subsection*{10.3 Assertion Statement}
	\begin{itemize}
		\item Used for internal consistency checks or error message generation.
		\item Can include an optional report string and severity name.
		\item Predefined severity names: NOTE, WARNING, ERROR, FAILURE.
		\item Default severity for assert is ERROR.
		\item If the condition is not met, we say that an assertion violation has
		occurred.
	\end{itemize}
	
	\subsection*{10.4 Report Statement}
	\begin{itemize}
		\item Used to output messages.
		\item Default severity name is NOTE.
	\end{itemize}
	
	\subsection*{10.5 Signal Assignment Statement}
	\begin{itemize}
		\item Typically considered a concurrent statement but can be used sequentially.
		\item Target is updated following specific delay mechanisms and waveforms.
		\item Delay mechanisms include transport, reject, and inertial.
		\item Waveforms can consist of values or nulls with optional delays.
	\end{itemize}
	
	\subsection*{10.6 Variable Assignment Statement}
	\begin{itemize}
		\item Assigns the value of an expression to a target variable.
	\end{itemize}
	
	\subsection*{10.7 Procedure Call Statement}
	\begin{itemize}
		\item Used to call a procedure.
		\item Can include actual parameters with positional or named associations.
	\end{itemize}
	
	\subsection*{10.8 If Statement}
	\begin{itemize}
		\item Implements conditional structures.
		\item Can include optional \texttt{elsif} and \texttt{else} clauses.
	\end{itemize}
	
	\subsection*{10.9 Case Statement}
	\begin{itemize}
		\item Executes one specific case of an expression equal to a choice.
		\item Choices must be constants of the same discrete type as the expression.
		\item Can include an optional \texttt{when others} clause if all choices are not covered.
	\end{itemize}
	
	\subsection*{10.10 Loop Statement}
	\begin{itemize}
		\item Supports three kinds of iteration statements: simple, \texttt{for}, and \texttt{while}.
		\item All loop types may include \texttt{next} and \texttt{exit} statements.
	\end{itemize}
	
	\subsection*{10.11 Next Statement}
	\begin{itemize}
		\item Used in a loop to cause the next iteration.
		\item May include an optional condition.
	\end{itemize}
	
	\subsection*{10.12 Exit Statement}
	\begin{itemize}
		\item Used in a loop to immediately exit the loop.
		\item May include an optional condition.
	\end{itemize}
	
	\subsection*{10.14 Return Statement}
	\begin{itemize}
		\item Required in a function and optional in a procedure.
		\item May include an optional expression to return a value.
	\end{itemize}
	
	\subsection*{10.15 Null Statement}
	\begin{itemize}
		\item Used when a statement is needed but there is nothing to do.
	\end{itemize}
	
	\subsection*{10.16 Sequential Block Statement}
	\begin{itemize}
		\item A sequential block statement encloses a sequence of sequential statements. Sequential block statements may
		be nested.
	\end{itemize}
	
	
	\section*{Chapter 11 Review and Notes}
	\begin{itemize}
		\item The VHDL language models real systems as a set of subsystems that operate concurrently.
		\item Concurrent statements are used to define interconnected blocks and processes that jointly describe the overall behavior or structure of a design.
	\end{itemize}
	
	\subsection*{11.2 Block Statement}
	\begin{itemize}
		\item A block statement defines an internal block representing a portion of a design
		\item Using of the block statement is supplying the limit the scope of the variables used within a portion of the code.
		\item  This can significantly improve code readability in a large design where signals can be declared and utilized in the same region
	\end{itemize}
	
	\subsection*{11.3 Process Statement}
	\begin{itemize}
		\item Processes are composed of sequential statements, but process declarations are concurrent statements.
		\item It is executed in parallel with other processes.
		\item It cannot contain concurrent statements.
		\item It allows access to signals defined in the architecture in which the process appears and to those defined
		in the entity to which the architecture is associated.
	\end{itemize}
	
	\subsection*{11.4 Concurrent Procedure Call Statements}
	\begin{itemize}
		\item It is a shorthand notation commonly used for processes.
		\item The body contains a sequential procedure but it is different from it, it is a concurrent statement.
	\end{itemize}
	
	\subsection*{11.5 Concurrent Assertion Statements}
	\begin{itemize}
		\item A concurrent assertion statement represents a passive process statement containing the specified assertion
		statement.
		\item The syntax appears to be sequential assertion statement but it is a concurrent statements like concurrent procedure call statements
	\end{itemize}
	
	\subsection*{11.6 Concurrent Signal Assignment Statements}
	\begin{itemize}
		\item Concurrent signal assignment statements are equivalent to sequential signal assignments contained in process statements
		\item Unlike ordinary signal assignments, concurrent signal assignment statements can be included in the statement part of an architecture body.
	\end{itemize}
	
	\subsection*{11.7 Component Instantiation Statements}
	\begin{itemize}
		\item Component instantiation allows you to instantiate one design unit (component) inside another design unit to create a hierarchically structured design description.
		\item To perform component instantiation:
		\begin{itemize}
			\item Create the design unit (entity and architecture) modeling the functionality to be instantiated.
			\item Declare the component to be instantiated in the declarative region of the parent design unit architecture.
			\item Instantiate and connect this component in the architecture body of the parent design unit.
			\item Map (connect) formal ports of the component to actual signals and ports of the parent design unit.
		\end{itemize}
	\end{itemize}
	
	\subsection*{11.8 Generate Statements}
	\begin{itemize}
		\item Generate statements are used to accomplish one of two goals:
		\begin{itemize}
			\item Replicating Logic in VHDL
			\item Turning on/off blocks of logic in VHDL
		\end{itemize}
		\item The generate keyword is always used in a combinational process or logic block.
		\item It should not be driven with a clock.
		\item If the digital designer wants to create replicated or expanded logic in VHDL, the generate statement with a for loop is the way to accomplish this task.
		\item The second use case is very handy for debugging purposes, or for switching out different components without having to edit lots of code.
		\item The designer needs to ensure that these generate blocks are mutually exclusive, such that no two can be active at the same time
	\end{itemize}
	
	\section*{Chapter 12 Review and Notes}
	\subsection*{12.1 Declerative Region}
	\begin{itemize}
		\item A declarative region in VHDL is a defined area where specific declarations are valid
		\item Declarative regions are established by constructs like entity, architecture, process, block, package, component, and configuration, each forming its own scope
	\end{itemize}
	
	\subsection*{12.2 Scope of Declarations}
	\begin{itemize}
		\item A declaration’s scope begins where it is declared and extends to the end of its nearest declarative region, defining where it can be used.
		\item The immediate scope covers the area from the start of the declaration to the end of its nearest declarative region
		\item Certain declarations, like those in package, record, subprogram parameters, or components (generic and port), can extend beyond their immediate scope, applying throughout their entire enclosing region or library
	\end{itemize}
	
	\subsection*{12.3 Visibility}
	\begin{itemize}
		\item Visibility rules define which identifier is accessible within a certain area, and overloaded names are clarified by additional rules
		\item Visibility can be achieved by selection (using use clauses) or directly, where identifiers are accessible in their immediate area unless hidden by another declaration with the same name
	\end{itemize}
	
	\subsection*{12.4 Use Clause}
	\begin{itemize}
		\item The use clause makes names defined in a library directly visible within another region of the VHDL code
		\item The visibility of a use clause starts right after it is written and continues to the end of its surrounding region, such as a design unit or configuration
	\end{itemize}
	
	\subsection*{12.5 The context of overload resolution}
	\begin{itemize}
		\item Overload resolution defines the exact meaning of an identifier or operator when multiple meanings are possible, ensuring a single valid interpretation within a specific context.
	\end{itemize}
	
	
	
	\section*{Chapter 13 Review and Notes}
	
	\subsection*{13.1 Design Units}
	\begin{itemize}
		\item Certain constructs are independently analyzed and inserted into a design library; these constructs are called
		design units
	\end{itemize}
	
	\subsection*{13.2 Design Libraries}
	\begin{itemize}
		\item The results of a VHDL compilation (analyze) are kept inside of a library for subsequent simulation, for use as a component in other designs
	\end{itemize}
	
	\subsection*{13.3 Context Declarations}
	\begin{itemize}
		\item A context declaration defines context items that may be referenced by design units.
	\end{itemize}
	
	\subsection*{13.4 Context Clauses}
	\begin{itemize}
		\item A context clause defines the initial name environment in which a design unit is analyzed.
	\end{itemize}
	
	\subsection*{13.5 Order of Analysis}
	\begin{itemize}
		\item The rules defining the order in which design units can be analyzed are direct consequences of the visibility
		rules. 
		\item Once you have analyzed all of the design units you need for a simulation run into a VHDL library, you can run the simulation
	\end{itemize}
	
	
	\subsection*{Chapter 14 Review and Notes}
	\begin{itemize}
		\item Definition of Elaboration of a block header:
		\begin{itemize}
			\item Purpose: Sets up the interface for each design block, including generics and ports
			\item Generics: Assigns values to parameters that control block behavior, like bit widths or timing
			\item Ports: Connects inputs and outputs to external signals or expressions
		\end{itemize}	
	\end{itemize}
	
	\begin{itemize}
		\item Definition of Elaboration of a declarative part:
		\begin{itemize}
			\item Purpose: Prepares internal elements like signals, constants, and variables in each block
			\item Declarations: Initializes constants, allocates memory for variables, and sets up signals
		\end{itemize}
	\end{itemize}
	
	\begin{itemize}
		\item Definition of Elaboration of a statement part:
		\begin{itemize}
			\item Purpose: Prepares executable statements for simulation, including both concurrent and sequential statements
			\item Concurrent Statements: Includes signal assignments and processes that run simultaneously
			\item Sequential Statements: Ordered operations within processes or subprograms
		\end{itemize}
	\end{itemize}
	
	\begin{itemize}
		\item Definition of Dynamic elaboration:
		\begin{itemize}
			\item Purpose: Manages runtime scenarios like deferred binding or conditional elaboration
			\item Deferred Binding: Allows components to be bound conditionally, adapting to runtime states
		\end{itemize}
	\end{itemize}
	
	\begin{itemize}
		\item Definition of Execution of a model:
		\begin{itemize}
			\item Purpose: Simulates the design by executing concurrent and sequential statements over time
		\end{itemize}
	\end{itemize}
	
	
	
	\subsection*{Chapter 15 Review and Notes}
	
	\begin{itemize}
		\item VHDL divides two main groups: graphic characters and format effectors
		\begin{itemize}
			\item Graphic Characters: Readability for users and compilers
			\item Format Effectors: For visual layout (line breaks, tabs, and new lines
		\end{itemize}
	\end{itemize}
	
	\subsection*{15.3 Lexical Elements}
	Seperators:
	\begin{itemize}
		\item Separates lexical elements 
		\item A separator is either a space character(SPACE or NBSP), a format effector, or the end of a line
	\end{itemize}
	
	Delimiters:
	\begin{itemize}
		\item Delimiter characters separate different elements in the syntax of the language
		\item The delimiters in VHDL are generally specific characters, and each one performs a specific function
	\end{itemize}
	
	Identifiers:
	\begin{itemize}
		\item Basic identifiers ;
		\begin{itemize}
			\item Define signals, ports, and variables
			\item Can Contain Letters, Digits, Underscores
		\end{itemize} 
		\item Extended Identifiers
		\begin{itemize}
			\item Define signals, ports, and variables
			\item Case Sensitive
			\item Enclosed in Backslashes
			\item Enable the Inclusion of Special Characters 
		\end{itemize}
	\end{itemize}
	
	Literals:
	\begin{itemize}
		\item Abstract Literals: Represent values in basic numerical types.
		\item Decimal Literals: Express numerical values (integer or fractional)
		\item Based Literals: Specify numerical values in a specific base (binary, octal, hexadecimal).
		\item Bit String Literals: Define numerical systems with specific bit sequences (B, O, X)
		\item Character Literals: Represent a single character
		\item String Literals: Represent a sequence of characters
	\end{itemize}
	
	
	
	
	\section*{Chapter 16 Review and Notes}
	\begin{itemize}
		\item This section describes predefined attributes of VHDL, and the packages that all VHDL implementations shall provide.
	\end{itemize}
	
	\subsection*{Predefined attributes}
	\begin{itemize}
		\item Predefined attributes denote values, functions, types, subtypes, mode views, signals and ranges associated with various kinds of named entities.
	\end{itemize}
	
	
	\subsection*{Active}
	\begin{itemize}
		\item When applied to a signal, this attribute works like a function call, returning true if s is active during the current simulation cycle and false if not
	\end{itemize}
	
	\subsection*{Ascending}
	\begin{itemize}
		\item This attributes can be applied to scalar types or objects of them, including subtypes and aliases. It returns a boolean value that will be true if p has ascending range or false if it's descending.
	\end{itemize}
	
	\subsection*{Base}
	\begin{itemize}
		\item When applied to an object, type, or subtype p, the base attribute returns the underlying type from which it originates. If there are multiple layers ıf subtypes, you get the root type that's not a subtype.
		\item This attribute cannot used standalone. It must appear in conjuction with a second attribute.
	\end{itemize}
	
	\subsection*{Converse}
	\begin{itemize}
		\item In VHDL2019 adds mode views to interfaces and this attribute along with them.
	\end{itemize}
	
	\subsection*{Delayed}
	\begin{itemize}
		\item When applied to a signal, this attribute produced a signal that's a copy of s, but with the transitions delayed by time units. The derived signal will have a delay of one delta cycle if the optional argument is omitted.
	\end{itemize}
	
	\subsection*{Designed-subtype}
	\begin{itemize}
		\item When called on access type or file type, the designated-subtype attribute returns the subtype that the object references.
	\end{itemize}
	
	\subsection*{Driving}
	\begin{itemize}
		\item This attribute acts as function returning a boolean value when applied to a signal. You can only use this attribute from within a process or equivalent concurrent statement/subprogram. It will return true if the process is driving the signal and false otherwise.
		\item When used in a regular signal, this attribute always returns true. That's because a process controlling a signal will always be driving it. However, that's not always the case when it comes guarded signals.
	\end{itemize}
	
	\subsection*{Driving-value}
	\begin{itemize}
		\item  When applied to a signal, this attribute works like a function call, returning the value that the enclosing process is driving onto the signal.
		\item Only used with a process or subprogram.
	\end{itemize}
	
	\subsection*{Element}
	 \begin{itemize}
	 	\item This attributes can only be applied to an array type or a signal or variable of an array type. When applied to such an object, it returns the subtype of the array elements.
	 	\item Can be used for declare new objects.
	 \end{itemize}
	
	\subsection*{Event}
	\begin{itemize}
		\item When applied to a signal, this attribute works like a function call, returning true if an event occured on during the current simulation cycle and false if not.
	\end{itemize}
	
	\subsection*{High}
	\begin{itemize}
		\item This attribute works like a function returning the upper bound of the object it's attached to. It may be used on any object whose range is contrained.
	\end{itemize}
	
	\subsection*{Left}
	\begin{itemize}
		\item This attribute works like a function returning the left bound of the object it's attached to. It may be used on any object whose is constrained
	\end{itemize}
	
	\subsection*{Low}
	\begin{itemize}
		\item This attribute works like a function returning the left bound of the object it's attached to. It may be used on any object whose range is constrained.
	\end{itemize}
	
	\subsection*{Quiet}
	\begin{itemize}
		\item When applied to a signal this attribute produces a drived signal of boolean type. The resulting signal's value is true if signal was quiet for time before the current simulation time. Otherwise it has the value false.
	\end{itemize}
	
	\subsection*{Right}
	\begin{itemize}
		\item This attribute works like a function returning the right bound of the object it’s attached to. It may be used on any object whose range is constrained.
	\end{itemize}
	
	\subsection*{Stable}
	\begin{itemize}
		\item When applied to a signal, this attribute produces a derived signal of boolean type, The resulting signal's value is falsse if there were events on signal for time before the current simulation time. If there were no events, it is true
	\end{itemize}
	
	
	
	
	\section*{Chapter 17 Review and Notes}
	\begin{itemize}
		\item VHPI is an application-programming interface to VHDL tools that allows programmatic access to a VHDL model.
		\item The information model is expressed in an object-oriented manner ass a set fo classes that bear relationships to one another.
		\item The properties this object-oriented manners is some of them are static while others are dynamic.
		\item The VHPI also provides utility functions for such purposes as printing, error checking, and tool control.
		\item There are some naming conventions for VHPI.
	\end{itemize}
	
	\subsection*{Capability Sets}
	\begin{itemize}
		\item It defines the utilities for simulator. Utility capabilities for printing, error checking, and tool control are also offered by the VHPI.
		\item A simulator's capabilities are groups of characteristics that let users test its functionality and compatibility.
	\end{itemize}
	
	\subsection*{Handles}
	\begin{itemize}
		\item A handle allows a VHPI program to refer to an object without assuming details of the representation of the object.
		\item To carry out tasks like value reading, writing, or property querying, handles are retrieved using particular VHPI functions. 
	\end{itemize}
	
	\section*{Chapter 18 Review and Notes}
	\begin{itemize}
		\item VHPI access functions are used by VHPI programs to access the information model of a VHDL model.
	\end{itemize}
	
	
	
\end{document}
