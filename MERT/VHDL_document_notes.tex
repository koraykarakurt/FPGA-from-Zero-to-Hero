\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\geometry{margin=1in}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{graphicx}

\title{False Paths Sprint-2 IEEE 1076-2019 VHDL Manual Review}
\author{Mert Ecevit}
\date{Edited at 05.12.2024}

\begin{document}
	
	\maketitle
	\begin{center}
		\textbf{Review and Taken Notes of the Document} \\
		\vspace{1em}
		\textit{Project Leader: Koray Karakurt}
	\end{center}
	
	\newpage
	
	\section*{Chapter 3 Review and Notes}
	
	\subsection*{3.2 Entity Declarations}
	\begin{itemize}[noitemsep]
		\item The entity declaration provides an external view of a component but does not provide information about how a component is implemented.
		\item An entity declaration defines the interface between a given design entity and the environment in which it is used.
		\item A given entity declaration may be shared by many design entities, each of which has a different architecture.
		\item The entity declarative part of a given entity declaration declares items that are common to all design entities whose interfaces are defined by the given entity declaration.
		\item The entity statement part contains concurrent statements that are common to each design entity with this interface.
		\item All entity statements shall be passive. Such statements may be used to monitor the operating conditions or characteristics of a design entity.
	\end{itemize}
	
	\subsection*{3.3 Architecture Declarations}
	\begin{itemize}[noitemsep]
		\item An architecture provides an “internal” view of an entity. An entity may have more than one architecture.
		\item It defines the relationships between the inputs and the outputs of a design entity which may be expressed in terms of:
		\begin{itemize}[noitemsep]
			\item Behavioural style
			\item Data flow style
			\item Structural style
		\end{itemize}
		\item An architecture determines the function of an entity.
		\item It consists of a declaration section where signals, types, constants, components, and subprograms are declared, followed by a collection of concurrent statements.
		\item More than one architecture body may exist corresponding to a given entity declaration.
		\item Each declares a different body with the same interface; thus, each together with the entity declaration represents a different design entity with the same interface.
		\item The architecture statement part contains statements that describe the internal organization and/or operation of the block defined by the design entity.
		\item All of the statements in the architecture statement part are concurrent statements, which execute asynchronously with respect to one another.
	\end{itemize}
	
	\subsection*{3.4 Configuration Declarations}
	\begin{itemize}[noitemsep]
		\item During the design process, a designer may want to experiment with different variations of a design by selecting different architectures.
		\item Configurations can be used to provide fast substitutions of component instances of a structural design.
	\end{itemize}
	
	\subsubsection*{3.4.1 Block Configurations}
	\begin{itemize}[noitemsep]
		\item Blocks are used to organise a set of concurrent statements hierarchically.
	\end{itemize}
	
	\subsubsection*{3.4.2 Component Configurations}
	\begin{itemize}
		\item A component declaration is required to make a design entity useable within the current design.
	\end{itemize}
	
	\section*{Chapter 4 Review and Notes}
	\subsection*{4.2 Subprogram Declarations}
	\begin{itemize}
		\item Subprograms consist of procedures and functions that can be invoked repeatedly from different locations in a VHDL description
		\item VHDL provides two kinds of subprograms : Procedures and Functions
		\item Note: Different from 1076-2002 Document The properties of implicitly declared subtypes denoted by return identifier added in this section.
	\end{itemize}
	
	\subsection*{4.3 Subprogram Bodies}
	\begin{itemize}
		\item A subprogram body specifies the execution of a subprogram
		\item The declaration of subprogram is optional, in absence of that subprogram specification acts as declaration
		\item It is an error if subprogram declarative part declares a shared variable.
	\end{itemize}
	
	\subsection*{4.4 Subprogram Instantiation Declarations}
	\begin{itemize}
		\item \textbf{Note :} This section is is absent in 1076-2002 Document
		\item The uninstantiated subprogram name shall denote an uninstantiated subprogram declared in a subprogram	declaration
		\item Subprogram instantiations is creating anonymous subprograms which allows you to declare and use subprograms  directly within the body of another construct, such as an architecture, without needing a separate named declaration.
	\end{itemize}
	
	\subsection*{4.5 Subprogram Overloading}
	\begin{itemize}
		\item  If the two subprogram names match, the parameter set/return values have to differ. This is called overloading and is allowed for all subprograms. It is especially useful when applied to operators, which can be seen as functions with a special name
		\item This allows, for example, to use the conventional ’+’ symbol for the addition of integer values and, likewise, with bit vectors that should be interpreted as numbers
	\end{itemize}
	
	\subsubsection*{4.5.3 Signatures}
	\begin{itemize}
		\item A signature distinguishes between overloaded subprograms and enumerationliterals based on their parameter and result type profiles. A signature may be used in an attribute name, entity designator or alias declaration.
	\end{itemize}
	
	\subsection*{4.6 Resolution Functions}
	\begin{itemize}
		\item A resolution function defines how values from multiple sources, multiple drivers, are resolved into a single value.
		\item A type or a signal may be defined to have a resolution. This type or signal uses the resolution functions when there are multiple drivers.
	\end{itemize}
	
	\subsection*{4.7 Package Declarations}
	\begin{itemize}
		\item The primary purpose of a package is to collect elements that can be shared among two or more design units.
		\item  It contains some common data types, constants, and subprogram specifications.
		\item A package declaration declares all the names of items that will be seen by the design units that use the package
	\end{itemize}
	
	\subsection*{4.8 Package Bodies}
	\begin{itemize}
		\item A package body contains the implementation details of the subprograms declared in the package declaration.
		\item A package body is not required if no subprograms are declared in a package declaration.
		\item The separation between package declaration and package body serves thesame purpose as the separation between the entity declaration and architecture body.
	\end{itemize}
	
	\subsection*{4.9 Package Instantiation Declarations}
	\begin{itemize}
		\item \textbf{Note :} This section is added in VHDL 1076-2008 document
		\item A package with a generic list is called an uninstantiated package
		\item The uninstantiated package serves as a form of template that we must instantiate separately.
		\item Uninstantiated packages and package instances that are declared as design units and stored in a design library, they  can be written as a further form of design unit
	\end{itemize}
	
	\subsection*{4.10 Conformance Rules}
	\begin{itemize}
		\item Two specifications for one subprogram are conform if 
		\begin{itemize}
			\item A numeric literal can be replaced by a different numeric literal if and only if both have the same
			value.
			\item A simple name can be replaced by an expanded name in which this simple name is the suffix if, and
			only if, at both places the meaning of the simple name is given by the same declaration.
		\end{itemize}
		both specifications are made up of the same sequence of lexical elements and corresponding lexical elements have the same meaning
	\end{itemize}
	
	\section*{Chapter 5 Review and Notes}
	Data types are crucial to the modeling and manipulation of data in the hardware design in VHDL
	
	\subsection*{5.2 Scalar Types}
	\begin{itemize}
		\item Scalar types consist of enumeration types, integer types, physical types, and floating-point types
		\item Enumeration types and integer types are called discrete types. 
		\item Integer types, floating-point types, and physical types are called numeric types.
	\end{itemize}
	
	\subsubsection*{5.2.2 Enumeration types}
	\begin{itemize}
		\item In VHDL, enumeration data types let you provide a collection of named values.
	\end{itemize}
	
	\subsubsection*{5.2.3 Integer Types}
	\begin{itemize}
		\item The signed integers that fall inside a given range are represented by the integer data type
	\end{itemize}
	
	\subsubsection*{5.2.4 Physical Types}
	\begin{itemize}
		\item Physical type is a numeric scalar that represents some quantity
	\end{itemize}
	
	\subsubsection*{5.2.5 Floating-Point Types}
	\begin{itemize}
		\item Floating point type provides an approximation of the real number value.
	\end{itemize}
	
	\subsection*{5.3 Composite Types}
	\begin{itemize}
		\item A composite type object is one having multiple elements
	\end{itemize}
	
	\subsubsection*{5.3.2 Array Type}
	\begin{itemize}
		\item Collections of the same data type elements are referred to as arrays in VHDL
	\end{itemize}
	
	\subsubsection*{5.3.3 Record Type}
	\begin{itemize}
		\item Records define custom data types that contain multiple fields of different data types
	\end{itemize}
	
	\subsection*{5.4 Access Types}
	\begin{itemize}
		\item Access type allows to manipulate data, which are created dynamically during simulation and which exact size is not known in advance
	\end{itemize}
	
	\subsection*{5.5 File Types}
	\begin{itemize}
		\item A type that provides access to objects containing a sequence of values of a given type
	\end{itemize}
	
	\subsection*{5.6 Protection Types}
	\begin{itemize}
		\item Types which implements instantiatiable regions of sequential statements and have exclusive access to shared data
	\end{itemize}
	
	\subsection*{5.7 String Representation}
	\begin{itemize}
		\item Character arrays are called strings. Used frequently to manipulate files or textual data.
	\end{itemize}
	
	\subsection*{5.8 Unspecified Types}
	\begin{itemize}
		\item An unspecified type abstractly defines the type class for generics, ports, parameters, and external names
	\end{itemize}
	
	\section*{Chapter 6 Review and Notes}
	\begin{itemize}
		\item Various declarations may be used in various design units.
	\end{itemize}
	
	\subsection*{6.2 Type Declarations}
	\begin{itemize}
		\item Custom structures and types for more accurate data representation are made possible by type declarations, which establish new data types in VHDL.
	\end{itemize}
	
	\subsection*{6.3 Subtype Declarations}
	\begin{itemize}
		\item A type together with a constraint.
	\end{itemize}
	
	\subsection*{6.4 Objects}
	\begin{itemize}
		\item Object are constants, signals and variables.
	\end{itemize}
	
	\subsection*{6.5 Interface Declarations}
	\begin{itemize}
		\item Interface declarations define interface objects of a precisely defined type.
		\item Interface objects are interface constants, interface signals, interface variables and interface files.
	\end{itemize}
	
	\subsection*{6.6 Alias Declarations}
	\begin{itemize}
		\item An alias is an alternative name for an existing object (signal, variable or constant). They don't define a new object.
	\end{itemize}
	
	\subsection*{6.7 Attribute Declarations}
	\begin{itemize}
		\item Attributes are user-defined properties attached to types, signals, entities, etc. They can store metadata or control simulation aspects.
	\end{itemize}
	
	\subsection*{6.8 Component Declarations}
	\begin{itemize}
		\item Components act as templates for modules or logic blocks that can be instantiated multiple times in a design. This allows reusability and modular design.
	\end{itemize}
	
	
	
	\section{Chapter 7 Review and Notes}
	\begin{itemize}
		\item In VHDL, Specifications are used to define additional information associated with entity in a design.
	\end{itemize}
	
	\subsection*{7.2 Attribute Specifications}
	\begin{itemize}
		\item Attributes are a feature of VHDL that allow you to extract additional information about an object.
	\end{itemize}
	
	\subsection*{7.3 Configuration Specifications}
	\begin{itemize}
		\item A VHDL configuration specification defines how instances of a specific component are connected and used in a design.
		\item It associates component instances with binding information, determining the role of the component within the design structure.
	\end{itemize}
	
	\subsection*{7.4 Disconnection Specification}
	\begin{itemize}
		\item A disconnection specification defines the time delay after which the driver of a guarded signal will automatically disconnect. It controls how long a signal remains active before it is disconnected.
	\end{itemize}
	
	
	
	\section*{Chapter 8 Review and Notes}
	\begin{itemize}
		\item In code, names refer to various entities like objects, values, methods, attributes, or slices.
	\end{itemize}
	
	\subsection*{8.2 Simple Names}
	\begin{itemize}
		\item While selected names denote a sub-element, simple names explicitly identify an item.
	\end{itemize}
	
	\subsection*{8.3 Selected Names}
	\begin{itemize}
		\item When referring to an entity that is declared within another entity or a design library, selected names are utilized.
	\end{itemize}
	
	\subsection*{8.4 Indexed Names}
	\begin{itemize}
		\item The indexed name indicates an element of an array, which is indicated by an expression list forming the array index.
	\end{itemize}
	
	\subsection*{8.5 Slice Names}
	\begin{itemize}
		\item The slice name allows indicating a part of a one-dimensional array. The slice name is called a null slice if its discrete range is a null range
	\end{itemize}
	
	\subsection*{8.6 Attribute Names}
	\begin{itemize}
		\item The attribute name consists of two elements: a prefix and an attribute designator
	\end{itemize}
	
	\subsection*{8.7 External Names}
	\begin{itemize}
		\item An object designated in the design hierarchy that contains the external name is indicated by its external name.
	\end{itemize}
	
	
	\section*{Chapter 9 Review and Notes}
	\begin{itemize}
		\item A formula that defines the computation of a value.
		\item The type of an expression depends only upon 
		\begin{itemize}
			\item The types of its operands 
			\item On the operators applied
		\end{itemize}
		\item The operators that can be used in expressions are defined below:
		% TODO: \usepackage{graphicx} required
		\begin{figure}
			\centering
			\includegraphics[width=0.7\linewidth]{"../../../../../Pictures/Screenshots/Ekran görüntüsü 2024-12-09 002158"}
			\caption{}
			\label{fig:ekran-goruntusu-2024-12-09-002158}
		\end{figure}
		\begin{figure}
			\centering
			\includegraphics[width=0.7\linewidth]{"../../../../../Pictures/Screenshots/Ekran görüntüsü 2024-12-09 002209"}
			\caption{}
			\label{fig:ekran-goruntusu-2024-12-09-002209}
		\end{figure}
		\begin{figure}
			\centering
			\includegraphics[width=0.7\linewidth]{"../../../../../Pictures/Screenshots/Ekran görüntüsü 2024-12-09 002215"}
			\caption{}
			\label{fig:ekran-goruntusu-2024-12-09-002215}
		\end{figure}	
	\end{itemize}
	
	\subsection*{9.3 Operands}
	\begin{itemize}
		\item The operands in an expression include names (that denote objects, values, or attributes that result in a value),
		literals, aggregates, function calls, qualified expressions, type conversions, and allocators. In addition, an
		expression enclosed in parentheses may be an operand in an expression.
	\end{itemize}
	
	
	\subsection*{9.4 Static Expressions}
	\begin{itemize}
		\item Utilized in constant declarations or restrictions; fully computed at compile time.
		\item There are two categories of static expression:
		\begin{itemize}
			\item If every operator in expression is an implicit defined operator, these are called \textbf{locally static}  expressions
			\item If every in the expression is a pure function and every primary in the expression is a global static primary, they are called \textbf{globally static}  expressions
		\end{itemize}
	\end{itemize}
	
	\subsection*{9.5 Universal Expressions}
	\begin{itemize}
		\item A universal expression is either an expression that delivers a result of type universal integer or one that delivers a result of type \textbf{universal real}
		\item The same operations are predefined for the type \textbf{universal integer} as for any integer type
		\item The same operations are predefined for the type \textbf{universal real} as for any floating point type
		\item In addition, these operations include the multiplication and division operators
		
	\end{itemize}
	
	
	
\end{document}
